操作系统

1. 进程的有哪几种状态，状态转换图，及导致转换的事件。
2. 进程与线程的区别。
3. 进程通信的几种方式。
4. 线程同步几种方式。(一定要会写生产者、消费者问题，完全消化理解)
5. 线程的实现方式. (也就是用户线程与内核线程的区别)
6. 用户态和核心态的区别。
7. 用户栈和内核栈的区别。
8. 内存池、进程池、线程池。(c++程序员必须掌握)
9. 死锁的概念，导致死锁的原因.
10. 导致死锁的四个必要条件。
11. 处理死锁的四个方式。
12. 预防死锁的方法、避免死锁的方法。
13. 进程调度算法。
14. Windows内存管理的方式(块式、页式、段式、段页式).
15. 内存连续分配方式采用的几种算法及各自优劣。
16. 动态链接及静态链接.
17. 基本分页、请求分页储存管理方式。
18. 基本分段、请求分段储存管理方式。
19. 分段分页方式的比较各自优缺点。
20. 几种页面置换算法，会算所需换页数。(LRU用程序如何实现？)
21. 虚拟内存的定义及实现方式。
22. 操作系统的四个特性。
23. DMA。
24. Spooling。
25. 外存分配的几种方式，及各种优劣。
26. 大端存储 vs 小端存储
    1) Big-Endian   就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
        PowerPC、IBM、Sun
    2) Little-Endian    就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
        X86、DEC

    一般 操作系统都是小端，而通讯协议是大端的.

    e.g.
    16bit宽的数 0x1234
           内存地址        小端       大端 
        低 0x4000      低 0x34    高 0x12
        高 0x4001      高 0x12    低 0x34

    大端存储 因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。
    小端存储 第一个字节是它的低位，符号位在最后一个字节，
        这样在做数值四则运算时从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效。


    如何判断 :
        BOOL IsBigEndian()
        {
            int a = 0x1234;
            char b =  *(char *)&a;  //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分
            if( b == 0x12)
            {
                return TRUE;
            }
            return FALSE;
        }

        Java(Java隐藏了 不允许依赖于大小端的代码,但是可以查)
            if(ByteOrder.nativeOrder()== ByteOrder.BIG_ENDIAN)
                System.out.println("big endian");
            else System.out.println("little endian");
            
    如何转换 :
        uint32_t reversebytes_uint32t(uint32_t value){
            return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 | 
                (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24; 
        }
    移位运算
        将低8位（0~8位）左移24位 变成了高8位（24~32位）+
        8~16位 左移8位 变成了（16~24位）+
        将原高8位和高16位右移 变成了新的低8位和低16位。


27. 编译有依赖，怎么做到有序编译 =====> 拓扑排序

28. 外部排序
    有一个1G文件含字符串, 内存只有100M，怎么排序 ======> 外部排序
            外部排序指的是 大文件 的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，
        需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。

        外部排序最常用的算法是 多路归并排序，即将原文件分解成多个能够一次性装入内存的部分分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序

        一般提到排序都是指 内排序，e.g. : 快速排序，堆排序，归并排序等，所谓内排序就是可以在内存RAM中完成的排序

