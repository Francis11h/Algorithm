
字节 Byte
	Byte作为一个单位来处理一个二进制字符串, 是构成信息的一个小单位, 最常用的字节是 八位bit 的字节, 即它包含8位的二进制数.

	1B(Byte) = 8b(bit)

																byte 	[-128, 127] 				8  bits 8位二进制数
																short   [-32768, 32767]				16 bits 16位
																int 	[-2147483648, 2147483647]	32 bits
									数值类型				整数型	long  	[-2^63, 2^63 - 1] 			64 bits

														浮点型	float 	[1.4E-45, 3.4028235E38]		32 bits						直接赋值时必须在数字后加上f或F
																double 	[4.9E-324, 	]				64 bits						赋值时可以加d或D也可以不加

				基本数据类型			字符串类型 	char	存储Unicode码		[0, 2^16 - 1]				16 bits		
									逻辑类型   	Boolean     			true / false				1  bit

Java数据类型


				引用数据类型			类, 接口, 数组


byte 	[-128, 127]
	二进制8位bits能表示的最大值是 [1111 1111 == 255 ?], 但是为什么最大表示到127 ?
		因为对于计算机来说, 一个二进制数字它的最高位是符号位, 0表示正数, 1表示负数.
		所以 [1111 1111 == -127] 而 [0111 1111 == 127] 区间范围应该是 [-127, 127] 之间
	那么 问题来了 !!! 我们都知道一个Byte能表达的数字范围是[-128, 127] 那么这个 -128 是怎么来的呢 ?
		这里就涉及到计算机的 原码、反码和补码 

		正数 : 原码 == 反码 == 补码
			  原码 0000 0001    反码 0000 0001    补码 0000 0001

		负数 : 
			  反码 ==  原码的 非符号位 取反
			  补码 ==  反码 + 1
			  原码 1000 0001    反码 1111 1110    补码 1111 1111

		计算机内部是用补码来存储一个数的(别管正数负数 我们计算机里存的都是他们的补码 尽管正数的原码和补码是一样的)

			为什么要用补码来存呢？
			对于一个正常人来说  需要把这个二进制转成带符号的十进制自然数进行加减 由于加减法计算方式是不同的 所以需要根据最高位符号位来区分是加法还是减法。
			而对于计算机来说 同样需要识别符号位来判断是要加还是要减 这样子势必会加大计算机的复杂性 因此我们希望符号位也可以参与到运算中。 也就是 100 - 50 ====> 100 + (-50) 把减法转化成加法

			1 - 1 ==> 1 + (-1) == 0

			原码相加
			0000 0001
			+
			1000 0001
			=
			1000 0010 == -2 结果显然是不正确的


			两个反码相加
			0000 0001   --->  0000 0001 (正数的反码还是本身原码)
			1000 0001   --->  1111 1110 (除了 符号位 其他位 1变0 0变1)  
							  =
							  1111 1111 (这个数是反码) 再转成原码(除了 符号位 其他位 1变0 0变1)  ==> 1000 0000 == -0 负0	
							  结果没有问题 但是从数学的角度 一个整数包括 负整数 0 和正整数 而这里出现了 负0, -0 和 0 都表示0 从编码的来说却出现了两个值 1000 0000 和 0000 0000

			再看两个补码相加

			0000 0001
			+	
			1111 1111
			=
			0000 0000(超过8位的值 被截掉) 转成原码 : (已知一个数的补码，求原码的操作分两种情况 : （1）如果补码的符号位为“0”，表示是一个正数，所以补码就是该数的原码 （2）如果补码符号位为1，其余各位取反，然后再整个数加1) 
												 还是 0000 0000 == 0
            
            所以 结果不仅正确 还解决了正负0 的问题
            而且 对于补码 的 加运算来说 是不可能出现 1000 0000 的情况, 因为两数 相加出现 1000 000 的情况 必然是两个正数想加 (0000 0001 + 0111 1111 = 1000 0000), 
            												（因为负数补码最小就是 1000 0001）, 而两个正数相加肯定不会出现负数的 所以 1000 0000 这个数 肯定不会因为相加而出现。
            因此 计算机规定 [补码 : 1000 0000] 就表示 -128

            所以总结一下，补码不仅能正确的运算，同时还可以多表示一个最低位，所以计算机用补码来存储数字。








https://blog.csdn.net/zl10086111/article/details/80907428

机器数和真值

机器数的概念 : 一个数在计算机中的二进制表示形式,叫做这个数的机器数. 
			注意 机器数是带符号的 : 在计算机中用一个数的最高位存放符号, 正数为0, 负数为1.

				比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。
				那么，这里的 00000011 和 10000011 就是机器数。

真值 : 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
		例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1





负数在内存中的存储形式

(1) 十进制负数是以其 补码 存储在内存上
(2) 但是在十六进制，负数在内存中储存的是原码















